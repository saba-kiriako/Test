<html><head><style>body {
   color: black;
}
</style></head><body><p>Let&#39;s refine and expand each slide to offer a more detailed explanation and include relevant Python code examples. Here&#39;s a deeper dive into each of the 20 slides:</p>
<h3 id="slide-1-introduction-to-error-handling-in-python">Slide 1: Introduction to Error Handling in Python</h3>
<ul>
<li><strong>Content</strong>: Importance of error handling and basic concepts.</li>
<li><strong>Explanation</strong>: Discuss how error handling enables developers to gracefully handle unexpected issues during program execution, thus ensuring the application continues to operate or fails cleanly.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># Potentially problematic code</span>
    <span class="hljs-literal">result</span> = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>
<span class="hljs-keyword">except</span> <span class="hljs-type">ZeroDivisionError</span>:
    <span class="hljs-comment"># Handling an exception</span>
    print(<span class="hljs-string">"Attempted to divide by zero."</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-2-basic-concepts-of-errors-and-exceptions">Slide 2: Basic Concepts of Errors and Exceptions</h3>
<ul>
<li><strong>Content</strong>: Differentiate between syntax errors and exceptions.</li>
<li><strong>Explanation</strong>: Syntax errors occur when Python parser detects an incorrect statement. Exceptions occur during execution due to incorrect operations (e.g., division by zero).</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Syntax Error Example</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello"</span>

<span class="hljs-comment"># Exception Example</span>
my_list = [1, 2, 3]
<span class="hljs-built_in">print</span>(my_list[3])
</code></pre>
</li>
</ul>
<h3 id="slide-3-the-exception-hierarchy">Slide 3: The Exception Hierarchy</h3>
<ul>
<li><strong>Content</strong>: Overview of Python&#39;s exception hierarchy.</li>
<li><strong>Explanation</strong>: Python&#39;s exceptions are classes that inherit from <code>BaseException</code>. At the top is <code>BaseException</code>, under which are <code>Exception</code>, <code>ArithmeticError</code>, <code>LookupError</code>, etc.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-comment"># Catching specific exceptions</span>
<span class="hljs-keyword">try</span>:
    x = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>
<span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:
    print(<span class="hljs-string">"Handling a specific error:"</span>, e)
</code></pre>
</li>
</ul>
<h3 id="slide-4-catching-exceptions">Slide 4: Catching Exceptions</h3>
<ul>
<li><strong>Content</strong>: Using try and except blocks.</li>
<li><strong>Explanation</strong>: <code>try</code> block allows you to test a block of code for errors. <code>except</code> block lets you handle the error.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># Code that may throw an exception</span>
    x = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>
<span class="hljs-keyword">except</span> ZeroDivisionError:
    <span class="hljs-comment"># What to do if the exception occurs</span>
    print(<span class="hljs-string">"You cannot divide by zero!"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-5-the-else-clause">Slide 5: The Else Clause</h3>
<ul>
<li><strong>Content</strong>: Using the else clause in try-except blocks.</li>
<li><strong>Explanation</strong>: The <code>else</code> clause runs if the code inside the <code>try</code> does not raise an exception.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    print(<span class="hljs-string">"Hello"</span>)
<span class="hljs-keyword">except</span> KeyError:
    print(<span class="hljs-string">"A KeyError occurred!"</span>)
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">"Nothing went wrong!"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-6-the-finally-clause">Slide 6: The Finally Clause</h3>
<ul>
<li><strong>Content</strong>: Using the finally clause.</li>
<li><strong>Explanation</strong>: <code>finally</code> block will be executed no matter if the try block raises an error or not.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    print(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)
<span class="hljs-keyword">except</span> ZeroDivisionError:
    print(<span class="hljs-string">"Division by zero!"</span>)
<span class="hljs-keyword">finally</span>:
    print(<span class="hljs-string">"This code will run no matter what"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-7-raising-exceptions">Slide 7: Raising Exceptions</h3>
<ul>
<li><strong>Content</strong>: How to raise exceptions with <code>raise</code>.</li>
<li><strong>Explanation</strong>: You can throw exceptions if conditions require it using the <code>raise</code> statement.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python">x = -<span class="hljs-number">1</span>
<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:
    <span class="hljs-keyword">raise</span> <span class="hljs-keyword">Exception</span>(<span class="hljs-string">"Sorry, no numbers below zero"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-8-creating-custom-exceptions">Slide 8: Creating Custom Exceptions</h3>
<ul>
<li><strong>Content</strong>: Defining your own exception classes.</li>
<li><strong>Explanation</strong>: Custom exceptions are useful for creating meaningful error messages and handling specific error cases.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyError</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">"An error occurred"</span>)
<span class="hljs-keyword">except</span> MyError <span class="hljs-keyword">as</span> e:
    print(e)
</code></pre>
</li>
</ul>
<h3 id="slide-9-handling-multiple-exceptions">Slide 9: Handling Multiple Exceptions</h3>
<ul>
<li><strong>Content</strong>: Catching multiple exceptions in a single block.</li>
<li><strong>Explanation</strong>: You can catch multiple exceptions as a tuple in an except clause.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># code that can raise multiple exceptions</span>
    dict()[<span class="hljs-string">"invalid_key"</span>]
<span class="hljs-keyword">except</span> (KeyError, IndexError) <span class="hljs-keyword">as</span> e:
    print(f<span class="hljs-string">"Logging an error: {e}"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-10-the-assert-statement">Slide 10: The Assert Statement</h3>
<ul>
<li><strong>Content</strong>: Using assertions in Python.</li>
<li><strong>Explanation</strong>: Assertions can be used to make sure that certain conditions are met during development. They raise an <code>AssertionError</code> if the condition is <code>False</code>.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python">assert <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span>, <span class="hljs-string">"The calculation is wrong"</span>
</code></pre>
</li>
</ul>
<h3 id="slide-11-using-try-with-else-clause">Slide 11: Using Try with Else Clause</h3>
<ul>
<li><strong>Content</strong>: Detailed use of else in try blocks.</li>
<li><p><strong>Explanation</strong>: Demonstrates the practical use of else for sections of code that should run only if</p>
<p>the try block did not raise an exception.</p>
</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    value = <span class="hljs-keyword">int</span>(input(<span class="hljs-string">"Enter a number: "</span>))
except ValueError:
    print(<span class="hljs-string">"You must enter a valid number!"</span>)
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">"You entered a valid number!"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-12-exception-chaining">Slide 12: Exception Chaining</h3>
<ul>
<li><strong>Content</strong>: Understanding exception chaining in Python.</li>
<li><strong>Explanation</strong>: Python allows you to chain exceptions to maintain both the stack trace and the cause of the exception.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">raise</span> <span class="hljs-type">KeyError</span>(<span class="hljs-string">"This is a key error"</span>)
<span class="hljs-keyword">except</span> <span class="hljs-type">KeyError</span> <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">raise</span> <span class="hljs-type">RuntimeError</span>(<span class="hljs-string">"Now handling the error"</span>) <span class="hljs-keyword">from</span> e
</code></pre>
</li>
</ul>
<h3 id="slide-13-handling-exceptions-with-context-managers">Slide 13: Handling Exceptions with Context Managers</h3>
<ul>
<li><strong>Content</strong>: Use of context managers for handling exceptions.</li>
<li><strong>Explanation</strong>: Context managers ensure that resources are managed efficiently, even when errors occur.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(<span class="hljs-string">"file.txt"</span>, <span class="hljs-string">"r"</span>) as f:
    read_data = f.read()
# <span class="hljs-keyword">File</span> <span class="hljs-keyword">is</span> automatically closed <span class="hljs-keyword">after</span> the <span class="hljs-keyword">block</span>, even <span class="hljs-keyword">if</span> an <span class="hljs-literal">error</span> occurs
</code></pre>
</li>
</ul>
<h3 id="slide-14-debugging-with-pdb">Slide 14: Debugging with PDB</h3>
<ul>
<li><strong>Content</strong>: Introduction to Python&#39;s debugger (pdb).</li>
<li><strong>Explanation</strong>: How to use pdb to step through Python code and find errors.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> pdb;</span> pdb.set_trace()
</code></pre>
</li>
</ul>
<h3 id="slide-15-logging-exceptions">Slide 15: Logging Exceptions</h3>
<ul>
<li><strong>Content</strong>: How to log exceptions.</li>
<li><strong>Explanation</strong>: Using Python&#39;s logging module to log exceptions and errors instead of printing them directly.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">import</span> logging
logging.basicConfig(level=logging.<span class="hljs-built_in">ERROR</span>)
logging.<span class="hljs-built_in">error</span>(<span class="hljs-comment">'An error occurred!')</span>
</code></pre>
</li>
</ul>
<h3 id="slide-16-best-practices-for-error-handling">Slide 16: Best Practices for Error Handling</h3>
<ul>
<li><strong>Content</strong>: Guidelines and best practices in handling exceptions.</li>
<li><strong>Explanation</strong>: Discuss common pitfalls such as catching too general exceptions and how to avoid them.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># risky code</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:  <span class="hljs-comment"># Too general exception</span>
    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># Handling</span>
</code></pre>
</li>
</ul>
<h3 id="slide-17-performance-implications">Slide 17: Performance Implications</h3>
<ul>
<li><strong>Content</strong>: Performance considerations with exceptions.</li>
<li><strong>Explanation</strong>: How relying too much on exceptions can affect the performance of an application.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python">import <span class="hljs-built_in">time</span>

start_time = <span class="hljs-built_in">time</span>.<span class="hljs-built_in">time</span>()
<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># perform some operations that could fail</span>
    pass
except KeyError:
    pass
print(<span class="hljs-string">"Time taken:"</span>, <span class="hljs-built_in">time</span>.<span class="hljs-built_in">time</span>() - start_time)
</code></pre>
</li>
</ul>
<h3 id="slide-18-testing-for-exceptions">Slide 18: Testing for Exceptions</h3>
<ul>
<li><strong>Content</strong>: Writing tests that expect exceptions.</li>
<li><strong>Explanation</strong>: How to use unit tests to ensure your code properly raises expected exceptions.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> unittest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raise_error</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"A value error occurred!"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRaiseError</span><span class="hljs-params">(unittest.TestCase)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_raise_error</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">with</span> self.assertRaises(ValueError):
            raise_error()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    unittest.main()
</code></pre>
</li>
</ul>
<h3 id="slide-19-advanced-exception-handling-techniques">Slide 19: Advanced Exception Handling Techniques</h3>
<ul>
<li><strong>Content</strong>: Advanced topics like exception hook.</li>
<li><strong>Explanation</strong>: Customizing exception handling to modify Python&#39;s default behavior.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> sys

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_exception_hook</span><span class="hljs-params">(exctype, value, traceback)</span>:</span>
    print(<span class="hljs-string">'Unhandled exception:'</span>, exctype, value)

sys.excepthook = my_exception_hook
<span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"This error will use a custom hook."</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-20-summary-and-best-practices">Slide 20: Summary and Best Practices</h3>
<ul>
<li><strong>Content</strong>: Recap of key points and best practices.</li>
<li><strong>Explanation</strong>: Summarize the importance of mastering error handling in Python to write robust and maintainable code.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-comment"># Summary of key syntax</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># do something</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># handle exception</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># execute if no exceptions</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># always execute</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
</li>
</ul>
<p>Certainly! Let&#39;s provide a deeper explanation of custom exceptions:</p>
<h3 id="slide-8-creating-custom-exceptions">Slide 8: Creating Custom Exceptions</h3>
<ul>
<li><strong>Content</strong>: Crafting your own exception classes.</li>
<li><p><strong>Explanation</strong>: Python allows developers to define their own custom exception classes by subclassing from the built-in <code>Exception</code> class or any other appropriate built-in exception class.</p>
<ul>
<li><p><strong>Customization</strong>: Custom exceptions can be tailored to specific scenarios or domain-specific errors that are relevant to the application being developed.</p>
</li>
<li><p><strong>Benefits</strong>: By defining custom exception classes, developers can provide more meaningful error messages, enhance the clarity and readability of their code, and ensure that exceptions are properly handled and distinguished from built-in exceptions.</p>
</li>
<li><p><strong>Best Practices</strong>: When creating custom exceptions, it&#39;s a good practice to follow the naming conventions for exception classes, provide informative docstrings, and ensure that custom exceptions are appropriately documented and understood by other developers working on the codebase.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithdrawalError</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Exception raised for errors during withdrawal process."""</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, amount, balance)</span>:</span>
        self.amount = amount
        self.balance = balance
        super().__init__(f<span class="hljs-string">"Cannot withdraw {amount} from balance {balance}"</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(amount, balance)</span>:</span>
    <span class="hljs-keyword">if</span> amount &gt; balance:
        <span class="hljs-keyword">raise</span> WithdrawalError(amount, balance)
    <span class="hljs-comment"># Withdrawal logic goes here</span>

<span class="hljs-keyword">try</span>:
    withdraw(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>)
<span class="hljs-keyword">except</span> WithdrawalError <span class="hljs-keyword">as</span> e:
    print(<span class="hljs-string">"WithdrawalError:"</span>, e)
</code></pre>
<p>In this example, we define a custom exception class <code>WithdrawalError</code>, which is raised when a withdrawal operation fails due to insufficient funds. The custom exception class accepts parameters <code>amount</code> and <code>balance</code>, allowing for detailed error messages that include information about the attempted withdrawal amount and the current account balance. This enhances the clarity and informativeness of the exception, enabling better error handling and debugging.</p>
</li>
</ul>
<p>Let&#39;s elaborate on handling multiple exceptions:</p>
<h3 id="slide-9-handling-multiple-exceptions">Slide 9: Handling Multiple Exceptions</h3>
<ul>
<li><strong>Content</strong>: Techniques for catching multiple exceptions.</li>
<li><p><strong>Explanation</strong>: Python allows developers to catch multiple exceptions in a single <code>except</code> block by specifying them as a tuple. This feature simplifies error handling and makes the code more concise and readable.</p>
<ul>
<li><p><strong>Multiple Exceptions</strong>: It&#39;s common for code blocks to contain operations that may raise different types of exceptions. By catching multiple exceptions together, developers can handle them uniformly or provide specific handling for each type of exception.</p>
</li>
<li><p><strong>Order Matters</strong>: When catching multiple exceptions, it&#39;s important to consider the order of the exception types. Python evaluates the <code>except</code> blocks in the order they are defined, and the first matching block will be executed. Therefore, more specific exceptions should be listed first, followed by more general ones.</p>
</li>
<li><p><strong>Exception as Alias</strong>: In addition to catching multiple exceptions explicitly, Python also allows developers to assign an alias to the caught exception object, enabling access to specific attributes or properties of the exception for further processing or logging.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># Code block that may raise multiple types of exceptions</span>
    <span class="hljs-built_in">file</span> = <span class="hljs-built_in">open</span>(<span class="hljs-string">"nonexistent_file.txt"</span>, <span class="hljs-string">"r"</span>)
    data = <span class="hljs-built_in">file</span>.<span class="hljs-built_in">read</span>()
    <span class="hljs-built_in">value</span> = int(<span class="hljs-string">"not_an_integer"</span>)
except (FileNotFoundError, ValueError) <span class="hljs-keyword">as</span> e:
    print(<span class="hljs-string">"Caught multiple exceptions:"</span>, e)
</code></pre>
<p>In this example, we attempt to open a file for reading and convert a string to an integer. Both operations may raise different types of exceptions (<code>FileNotFoundError</code> and <code>ValueError</code>). By catching them together in a single <code>except</code> block, we can handle both scenarios uniformly, improving the robustness and maintainability of the code.</p>
</li>
</ul>
<p>Certainly! Let&#39;s provide a more detailed explanation of the assert statement:</p>
<h3 id="slide-10-the-assert-statement">Slide 10: The Assert Statement</h3>
<ul>
<li><strong>Content</strong>: Using the assert statement for conditions.</li>
<li><p><strong>Explanation</strong>: The <code>assert</code> statement in Python is a powerful tool for debugging and testing purposes. It allows developers to assert that certain conditions are met during program execution and raises an <code>AssertionError</code> exception if the condition evaluates to False.</p>
<ul>
<li><p><strong>Purpose</strong>: Assert statements are primarily used to perform internal self-checks within code, ensuring that certain assumptions about the program state or input data hold true.</p>
</li>
<li><p><strong>Debugging</strong>: During development and debugging, assert statements help detect logical errors and invalid assumptions early in the development process, making it easier to identify and fix bugs.</p>
</li>
<li><p><strong>Testing</strong>: In addition to debugging, assert statements are commonly used in unit testing frameworks to verify the correctness of program behavior and expected outcomes. They serve as explicit checks that validate the behavior of functions or methods under different conditions.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_square_root</span><span class="hljs-params">(number)</span>:</span>
    <span class="hljs-keyword">assert</span> number &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">"Input number must be non-negative"</span>
    <span class="hljs-keyword">return</span> number ** <span class="hljs-number">0.5</span>

<span class="hljs-keyword">try</span>:
    calculate_square_root(<span class="hljs-number">-9</span>)
<span class="hljs-keyword">except</span> AssertionError <span class="hljs-keyword">as</span> e:
    print(<span class="hljs-string">"AssertionError:"</span>, e)
</code></pre>
<p>In this example, the <code>calculate_square_root</code> function asserts that the input number must be non-negative before performing the square root calculation. If the assertion fails (i.e., the input number is negative), an <code>AssertionError</code> is raised with a custom error message indicating the violation of the specified condition. This helps enforce preconditions and invariants, improving the reliability and correctness of the code.</p>
</li>
</ul>
<p>Let&#39;s provide a deeper explanation of the try with else clause:</p>
<h3 id="slide-11-using-try-with-else-clause">Slide 11: Using Try with Else Clause</h3>
<ul>
<li><strong>Content</strong>: Deep dive into using else with try blocks.</li>
<li><p><strong>Explanation</strong>: The <code>else</code> clause in a <code>try</code> block allows developers to execute code that should run only if no exceptions occur during the execution of the <code>try</code> block. It provides a convenient way to separate the main logic from the error-handling logic.</p>
<ul>
<li><p><strong>Conditional Execution</strong>: The <code>else</code> block is executed only if the <code>try</code> block completes without raising any exceptions. This allows developers to handle the normal, error-free execution path separately from exceptional cases.</p>
</li>
<li><p><strong>Code Clarity</strong>: Separating error-handling code from the main logic using the <code>else</code> clause enhances the readability and maintainability of the code by clearly delineating different execution paths.</p>
</li>
<li><p><strong>Use Cases</strong>: The <code>else</code> clause is often used for actions that should occur only if specific conditions are met, such as successful database operations, file I/O operations, or network requests.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span><span class="hljs-params">(x, y)</span>:</span>
    <span class="hljs-keyword">try</span>:
        result = x / y
    <span class="hljs-keyword">except</span> ZeroDivisionError:
        print(<span class="hljs-string">"Cannot divide by zero!"</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Division result:"</span>, result)

divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Output: Division result: 5.0</span>
divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># Output: Cannot divide by zero!</span>
</code></pre>
<p>In this example, the <code>divide</code> function attempts to perform division and prints the result if division is successful. If a <code>ZeroDivisionError</code> occurs, the function prints an error message. By using the <code>else</code> clause, the code that prints the division result is isolated from the error-handling logic, improving code clarity and maintainability.</p>
</li>
</ul>
<p>Let&#39;s delve deeper into the concept of exception chaining:</p>
<h3 id="slide-12-exception-chaining">Slide 12: Exception Chaining</h3>
<ul>
<li><strong>Content</strong>: Understanding exception chaining in Python.</li>
<li><p><strong>Explanation</strong>: Exception chaining allows developers to maintain the context of the original exception while raising a new exception. This feature provides a comprehensive view of the error stack trace and helps in debugging and understanding the root cause of the exception.</p>
<ul>
<li><p><strong>Context Preservation</strong>: When raising a new exception with the <code>raise ... from ...</code> syntax, Python preserves the traceback of the original exception, effectively chaining the exceptions together. This ensures that valuable information about the cause of the error is not lost.</p>
</li>
<li><p><strong>Use Cases</strong>: Exception chaining is useful in scenarios where an error occurs at a higher level of abstraction but is caused by an underlying issue. By chaining exceptions, developers can provide more detailed information about the entire error context, facilitating easier debugging and troubleshooting.</p>
</li>
<li><p><strong>Debugging Benefits</strong>: Exception chaining aids in identifying the precise location and nature of errors in complex codebases, enabling developers to diagnose and fix issues more efficiently.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">raise</span> <span class="hljs-type">KeyError</span>(<span class="hljs-string">"Original error"</span>)
<span class="hljs-keyword">except</span> <span class="hljs-type">KeyError</span> <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">raise</span> <span class="hljs-type">RuntimeError</span>(<span class="hljs-string">"New error"</span>) <span class="hljs-keyword">from</span> e
</code></pre>
<p>In this example, a <code>KeyError</code> exception is raised initially, indicating an error related to a dictionary key. However, a more generic <code>RuntimeError</code> exception is raised subsequently, with the original <code>KeyError</code> exception chained to it. This preserves the traceback of the original error, providing a clear indication of the root cause of the exception and the context in which it occurred.</p>
</li>
</ul>
<p>Let&#39;s provide a more detailed explanation of handling exceptions with context managers:</p>
<h3 id="slide-13-handling-exceptions-with-context-managers">Slide 13: Handling Exceptions with Context Managers</h3>
<ul>
<li><strong>Content</strong>: Employing context managers for handling exceptions.</li>
<li><p><strong>Explanation</strong>: Context managers in Python provide a convenient way to manage resources and ensure proper cleanup, even in the presence of exceptions. They encapsulate the setup and teardown logic associated with resources, such as files or network connections, in a clean and concise manner.</p>
<ul>
<li><p><strong>Resource Management</strong>: Context managers ensure that resources are acquired and released correctly, regardless of whether exceptions occur during the execution of the associated code block. This helps prevent resource leaks and ensures efficient resource utilization.</p>
</li>
<li><p><strong>Exception Handling</strong>: When an exception occurs within the context managed by a context manager, Python guarantees that the <code>__exit__</code> method of the context manager is called to perform cleanup operations. This allows developers to handle exceptions gracefully and maintain the integrity of the system.</p>
</li>
<li><p><strong>Use Cases</strong>: Context managers are commonly used for file I/O operations, database connections, network sockets, and other scenarios where resource management is critical.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"example.txt"</span>, <span class="hljs-string">"r"</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">file</span>:
    <span class="hljs-keyword">try</span>:
        data = <span class="hljs-built_in">file</span>.<span class="hljs-built_in">read</span>()
        <span class="hljs-comment"># Perform operations on the file data</span>
    except Exception <span class="hljs-keyword">as</span> e:
        print(<span class="hljs-string">"An error occurred:"</span>, e)
</code></pre>
<p>In this example, the <code>open</code> function is used as a context manager to open a file for reading. Within the <code>with</code> block, file operations are performed, and any exceptions that occur are caught and handled gracefully. Regardless of whether an exception occurs, the file is automatically closed when the <code>with</code> block exits, ensuring proper resource cleanup. This simplifies error handling and enhances the reliability of the code.</p>
</li>
</ul>
<p>Absolutely, let&#39;s delve deeper into the best practices for error handling:</p>
<h3 id="slide-16-best-practices-for-error-handling">Slide 16: Best Practices for Error Handling</h3>
<ul>
<li><strong>Content</strong>: Guidelines and best practices in handling exceptions.</li>
<li><p><strong>Explanation</strong>: Adhering to best practices in error handling is essential for writing maintainable, robust, and debuggable Python code.</p>
<ul>
<li><p><strong>Specific Exception Handling</strong>: Catch specific exceptions rather than using a generic catch-all approach. This allows for more precise error handling and ensures that only relevant exceptions are caught and handled.</p>
</li>
<li><p><strong>Avoid Bare Except Clauses</strong>: Avoid using bare <code>except</code> clauses, as they catch all exceptions indiscriminately, including system-exiting exceptions like <code>SystemExit</code> and <code>KeyboardInterrupt</code>. Instead, catch specific exceptions or use a more general <code>except Exception</code> clause if necessary.</p>
</li>
<li><p><strong>Cleanup with Finally</strong>: Use <code>finally</code> blocks to perform cleanup operations that should always execute, regardless of whether an exception occurs. <code>finally</code> blocks are useful for releasing resources, closing files, or cleaning up temporary data structures.</p>
</li>
<li><p><strong>Handle Exceptions Locally</strong>: Handle exceptions as close to their occurrence as possible, within the scope where the exception is most relevant. This promotes modular and focused error handling, making code easier to understand and maintain.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># Code block that may raise exceptions</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">except</span> SpecificException <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># Handle specific exceptions</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">except</span> AnotherSpecificException <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># Handle another specific exception</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># Handle any other exceptions</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">finally</span>:
    <span class="hljs-comment"># Cleanup code that always executes</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>In this example, best practices for error handling are demonstrated. Specific exceptions are caught individually, allowing for tailored error handling for each type of exception. A <code>finally</code> block ensures that cleanup operations are performed, regardless of whether an exception occurs. By following these best practices, code becomes more resilient, maintainable, and easier to debug.</p>
</li>
</ul>
<p>Let&#39;s dive deeper into the concept of testing for exceptions:</p>
<h3 id="slide-18-testing-for-exceptions">Slide 18: Testing for Exceptions</h3>
<ul>
<li><strong>Content</strong>: Writing tests that expect exceptions.</li>
<li><p><strong>Explanation</strong>: Testing for exceptions is a critical aspect of ensuring the reliability and robustness of Python code. It involves verifying that functions and methods correctly raise expected exceptions under specific conditions.</p>
<ul>
<li><p><strong>Unit Testing</strong>: Exception testing is commonly performed within unit tests, where individual components of the code are tested in isolation. Unit tests help identify and isolate issues early in the development process, making it easier to diagnose and fix bugs.</p>
</li>
<li><p><strong>Asserting Exceptions</strong>: Testing frameworks like <code>unittest</code> provide assertion methods such as <code>assertRaises</code> to verify that a specified exception is raised when a particular piece of code is executed. These assertion methods allow developers to express their expectations about the behavior of the code under test.</p>
</li>
<li><p><strong>Expected vs. Unexpected Exceptions</strong>: While testing for expected exceptions, it&#39;s essential to distinguish between exceptions that are intentionally raised by the code under test (expected exceptions) and unexpected exceptions that indicate bugs or unforeseen issues in the code.</p>
</li>
<li><p><strong>Coverage and Edge Cases</strong>: Effective exception testing should cover a wide range of scenarios and edge cases, including situations where exceptions are expected to be raised, as well as cases where exceptions should not occur.</p>
</li>
</ul>
</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python">import unittest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span><span class="hljs-params">(x, y)</span></span>:
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span>:
        raise ValueError(<span class="hljs-string">"Cannot divide by zero"</span>)
    <span class="hljs-keyword">return</span> x / y

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDivision</span>(<span class="hljs-title">unittest</span>.<span class="hljs-title">TestCase</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_divide_by_zero</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        with <span class="hljs-keyword">self</span>.assertRaises(ValueError):
            divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_divide_valid_input</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        result = divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">self</span>.assertEqual(result, <span class="hljs-number">5</span>)

<span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">"__main__"</span>:
    unittest.main()
</code></pre>
<p>In this example, two test cases are defined within a <code>unittest.TestCase</code> subclass. The first test case verifies that the <code>divide</code> function raises a <code>ValueError</code> when dividing by zero, while the second test case checks the result of a valid division operation. By asserting that specific exceptions are raised under defined conditions, developers can ensure the correctness and robustness of their code.</p>
</li>
</ul>
<p>Absolutely! Let&#39;s include more code examples to illustrate various aspects of error handling in Kedro projects:</p>
<h3 id="slide-21-error-handling-in-kedro-data-science-projects">Slide 21: Error Handling in Kedro Data Science Projects</h3>
<h4 id="section-1-introduction">Section 1: Introduction</h4>
<ul>
<li><strong>Content</strong>: Understanding the importance of error handling in Kedro projects.</li>
<li><strong>Explanation</strong>: Error handling is a critical aspect of developing data science projects using Kedro. It ensures that the pipeline operates reliably, data integrity is maintained, and errors are detected and handled gracefully.</li>
<li><strong>Code Example</strong>: None</li>
</ul>
<h3 id="slide-22-custom-error-messages">Slide 22: Custom Error Messages</h3>
<h4 id="section-2-custom-error-messages">Section 2: Custom Error Messages</h4>
<ul>
<li><strong>Content</strong>: Creating informative and descriptive error messages.</li>
<li><strong>Explanation</strong>: Custom error messages provide clarity and context when errors occur in the pipeline. By defining custom error classes or messages, developers can communicate the nature and location of the error more effectively, aiding in debugging and troubleshooting.</li>
<li><strong>Code Example</strong>:<pre><code class="lang-python"><span class="hljs-comment"># Example of custom error class for Kedro project</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataLoadError</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Exception raised for errors during data loading."""</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
</li>
</ul>
<h3 id="slide-23-logging-and-monitoring">Slide 23: Logging and Monitoring</h3>
<h4 id="section-3-logging-and-monitoring">Section 3: Logging and Monitoring</h4>
<ul>
<li><strong>Content</strong>: Leveraging Kedro&#39;s logging capabilities for error tracking.</li>
<li><strong>Explanation</strong>: Logging error messages using Kedro&#39;s logging framework allows developers to monitor pipeline execution, track data transformations, and identify error conditions. By logging errors at critical points in the pipeline, developers gain insights into the pipeline&#39;s behavior and can diagnose issues more effectively.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of logging error messages in a Kedro node</span>
<span class="hljs-keyword">import</span> logging

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess_data</span><span class="hljs-params">(context)</span>:</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Data preprocessing logic</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        logging.error(<span class="hljs-string">"Error occurred during data preprocessing: %s"</span>, e)
</code></pre>
</li>
</ul>
<h3 id="slide-24-validation-and-data-quality-checks">Slide 24: Validation and Data Quality Checks</h3>
<h4 id="section-4-validation-and-data-quality-checks">Section 4: Validation and Data Quality Checks</h4>
<ul>
<li><strong>Content</strong>: Implementing data validation and quality checks.</li>
<li><strong>Explanation</strong>: Data validation ensures that input and output data meet expected criteria and quality standards. Leveraging Kedro&#39;s <code>DataSet</code> abstraction, developers can validate data integrity, format, and schema, preventing errors caused by invalid or inconsistent data.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of data validation using Kedro's DataSet abstraction</span>
<span class="hljs-keyword">from</span> kedro.extras.datasets.pandas <span class="hljs-keyword">import</span> CSVDataSet
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_input_data</span><span class="hljs-params">(context)</span>:</span>
    input_data = context.catalog.load(<span class="hljs-string">"input_data"</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(input_data, pd.DataFrame) <span class="hljs-keyword">or</span> input_data.empty:
        <span class="hljs-keyword">raise</span> DataLoadError(<span class="hljs-string">"Invalid or empty input data"</span>)
</code></pre>
</li>
</ul>
<h3 id="slide-25-failure-modes-and-recovery">Slide 25: Failure Modes and Recovery</h3>
<h4 id="section-5-failure-modes-and-recovery">Section 5: Failure Modes and Recovery</h4>
<ul>
<li><strong>Content</strong>: Planning for failure modes and implementing error recovery strategies.</li>
<li><strong>Explanation</strong>: Anticipating failure modes and defining robust error recovery mechanisms are essential for maintaining pipeline resilience. Developers should design strategies for handling transient errors, retries, and fallback mechanisms to ensure pipeline continuity and data integrity in the face of failures.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of retry mechanism for a Kedro node using tenacity library</span>
<span class="hljs-keyword">from</span> tenacity <span class="hljs-keyword">import</span> retry, stop_after_attempt, wait_fixed

<span class="hljs-meta">@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data_with_retry</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-comment"># Process data with retry logic</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
</li>
</ul>
<h3 id="slide-26-testing-and-test-driven-development-tdd-">Slide 26: Testing and Test-Driven Development (TDD)</h3>
<h4 id="section-6-testing-and-test-driven-development-tdd-">Section 6: Testing and Test-Driven Development (TDD)</h4>
<ul>
<li><strong>Content</strong>: Adopting a test-driven development approach to error handling.</li>
<li><strong>Explanation</strong>: Test-driven development (TDD) encourages writing tests before implementing code logic, ensuring that error handling mechanisms are thoroughly tested. By writing comprehensive unit tests and integration tests, developers can validate pipeline behavior under various conditions, including error scenarios.</li>
<li><p><strong>Code Example</strong>:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of unit test for a Kedro node using pytest</span>
<span class="hljs-keyword">import</span> pytest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_preprocess_data_raises_exception</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">with</span> pytest.raises(Exception):
        preprocess_data(context)
</code></pre>
</li>
</ul>
<h3 id="slide-27-documentation-and-error-reporting">Slide 27: Documentation and Error Reporting</h3>
<h4 id="section-7-documentation-and-error-reporting">Section 7: Documentation and Error Reporting</h4>
<ul>
<li><strong>Content</strong>: Documenting error handling procedures and establishing reporting channels.</li>
<li><strong>Explanation</strong>: Clear documentation of error handling procedures, including common error scenarios and troubleshooting steps, is crucial for maintaining code reliability and facilitating collaboration among team members. Establishing communication channels for reporting errors and issues encountered during pipeline execution ensures timely resolution and continuous improvement of the pipeline.</li>
<li><strong>Code Example</strong>: None</li>
</ul>
<h3 id="slide-28-conclusion">Slide 28: Conclusion</h3>
<h4 id="section-8-conclusion">Section 8: Conclusion</h4>
<ul>
<li><strong>Content</strong>: Summarizing the importance of robust error handling in Kedro projects.</li>
<li><strong>Explanation</strong>: Effective error handling is fundamental to developing reliable and maintainable data science projects using Kedro. By following best practices and incorporating error handling mechanisms into the pipeline design, developers can ensure data integrity, code reliability, and efficient troubleshooting, leading to successful project outcomes.</li>
<li><strong>Code Example</strong>: None</li>


Yes, the Tenacity library can definitely be used in production environments, and it can be particularly valuable there. In production, reliability and robustness of applications are critical. Transient failures due to temporary unavailability of services, network issues, rate limiting, and similar intermittent problems are common. Using a retry mechanism like Tenacity helps ensure that your application can handle these issues gracefully, improving its resilience and uptime.

### Benefits of Using Tenacity in Production

1. **Increased Robustness**: By retrying failed operations, your application can handle transient errors without crashing or failing outright, which is crucial in production.

2. **Configurable Policies**: Tenacity allows for sophisticated retry strategies, including exponential backoff, jitter, and custom stop conditions, which can be finely tuned to match the operational characteristics and requirements of your production environment.

3. **Improved User Experience**: For applications that rely on external services, using retries can prevent errors from propagating to end-users, thereby improving the overall user experience.

4. **Operational Efficiency**: Automatically retrying on failures can reduce the need for manual intervention from the operations team, leading to more efficient handling of common issues.

### Considerations for Using Tenacity in Production

While Tenacity is beneficial, there are several considerations you should take into account when implementing it in a production setting:

- **Avoiding Infinite Loops**: Make sure to set sensible limits on the number of retries and the conditions under which retries should stop (e.g., stop after a maximum number of attempts or a maximum time interval).

- **Performance Impact**: Retrying operations can increase response times and load on your systems, especially if not configured correctly (e.g., aggressive retry intervals). This can lead to worsened performance issues if not managed carefully.

- **Error Monitoring and Reporting**: Itâ€™s important to monitor the failures and retries to understand their causes. This involves logging retry attempts and failures properly, which can help in identifying and addressing the root causes of the issues.

- **Resource Usage**: Retries can increase resource consumption (CPU, memory, network bandwidth), particularly if many retries occur in a short period. This needs to be managed to avoid resource exhaustion.

- **Appropriate Use Cases**: Use retries primarily for handling errors that are expected to resolve on their own after a short period. For persistent or critical errors, other error-handling strategies might be more appropriate.

In summary, Tenacity is a powerful tool for enhancing the resilience of applications in production, particularly when dealing with external dependencies or operations prone to failure. Proper configuration and monitoring are essential to ensure it provides the intended benefits without introducing new issues.
</ul>
<p>These additional code examples provide further clarity and practical implementation details for error handling in Kedro projects, covering custom error messages, logging, validation, retry mechanisms, and testing.</p>
</body></html>

Certainly! Custom error messages are an important aspect of any application, as they help users and developers understand what went wrong and how to possibly fix it. By creating custom error classes, you can provide more specific error information tailored to the context of your application. Here are some additional examples that can be used in a Kedro project to handle different types of errors more effectively:

### Example 1: Data Validation Error
This example shows a custom error class that could be used when data does not meet certain validation criteria. This can be useful in scenarios where your pipeline expects data in a specific format or meeting particular constraints.

```python
class DataValidationError(Exception):
    """Exception raised for errors in the data validation process."""
    def __init__(self, message, data_id=None):
        super().__init__(message)
        self.data_id = data_id

# Example usage:
def validate_data(data, schema):
    if not conforms_to_schema(data, schema):
        raise DataValidationError("Data does not conform to expected schema.", data_id=data.get('id'))
```

### Example 2: Configuration Error
This example involves an error related to configuration issues, which can occur when there are missing or incorrect settings required for the application to run properly.

```python
class ConfigurationError(Exception):
    """Exception raised for errors in the application configuration."""
    def __init__(self, message, config_key):
        super().__init__(f"{message}. Check the configuration for '{config_key}'.")
        self.config_key = config_key

# Example usage:
def load_configuration(config_key):
    config_value = get_configuration(config_key)
    if config_value is None:
        raise ConfigurationError("Missing required configuration", config_key)
```

### Example 3: Resource Unavailable Error
This example is for a situation where an expected external resource (like a database or API) is unavailable.

```python
class ResourceUnavailableError(Exception):
    """Exception raised when an external resource is unavailable."""
    def __init__(self, resource_name, retry_after_seconds):
        super().__init__(f"{resource_name} is unavailable. Retry after {retry_after_seconds} seconds.")
        self.resource_name = resource_name
        self.retry_after_seconds = retry_after_seconds

# Example usage:
def access_resource(resource):
    try:
        resource.connect()
    except ConnectionError:
        raise ResourceUnavailableError(resource.name, 30)
```

### Example 4: Permission Denied Error
Lastly, an example dealing with permission issues, which are common in systems where access control is enforced.

```python
class PermissionDeniedError(Exception):
    """Exception raised when an operation is blocked due to insufficient permissions."""
    def __init__(self, operation, user_role):
        super().__init__(f"Permission denied for operation '{operation}' with role '{user_role}'.")
        self.operation = operation
        self.user_role = user_role

# Example usage:
def delete_file(user, file):
    if not user.has_permission('delete'):
        raise PermissionDeniedError('delete', user.role)
    file.delete()
```

### Importance of Custom Error Classes
These examples illustrate how custom error classes can provide more specific information about the nature of the error, which part of the system is affected, and what the probable cause might be. This can significantly aid in debugging and troubleshooting, especially in complex systems like those typically built with Kedro. Furthermore, well-defined error messages improve the maintainability of the code and make it easier for others to understand and fix issues quickly.



Let's expand Slide 6 and Slide 7 with more comprehensive details and practical guidelines to enhance understanding.

### Slide 6: Automating Drift Detection with Apache Airflow
- **Integration of MLflow with Airflow:** 
  - **Purpose:** Airflow acts as an orchestrator for MLflow tasks, scheduling and automating the execution of model evaluations to check for drift on a regular basis.
  - **Benefits:** Automating with Airflow ensures that drift checks are performed consistently and efficiently, minimizing manual oversight and reducing the likelihood of missed drift detections.
- **Example Workflow Configuration:**
  - **Step 1:** Set up the Airflow environment. This involves installing Airflow and setting up the necessary configurations, including the scheduler, executor, and web server components.
  - **Step 2:** Define the Airflow DAG (Directed Acyclic Graph). A DAG is a collection of tasks you want to run, organized in a way that reflects their relationships and dependencies.
    ```python
    from airflow import DAG
    from airflow.operators.python_operator import PythonOperator
    from datetime import datetime, timedelta

    def evaluate_model():
        # Code to initiate MLflow, load model, and log metrics
        mlflow.set_tracking_uri("http://your-mlflow-server:5000")
        with mlflow.start_run():
            model = mlflow.pyfunc.load_model('models:/your-model/Production')
            test_data, actual_labels = fetch_recent_data()  # Placeholder for actual data fetching function
            predictions = model.predict(test_data)
            accuracy = compute_accuracy(predictions, actual_labels)
            mlflow.log_metric("accuracy", accuracy)

    default_args = {
        'owner': 'airflow',
        'start_date': datetime(2023, 1, 1),
        'email_on_failure': False,
        'retries': 1,
        'retry_delay': timedelta(minutes=5),
    }
    dag = DAG('model_drift_evaluation', default_args=default_args, schedule_interval='@daily')

    evaluate_task = PythonOperator(
        task_id='evaluate_model_drift',
        python_callable=evaluate_model,
        dag=dag,
    )
    ```
  - **Step 3:** Schedule and monitor the DAG. Use the Airflow UI to monitor the performance and output of the scheduled tasks, adjusting parameters as necessary based on model performance and drift detection outcomes.

### Slide 7: Custom Metrics for Drift Detection
- **Defining Custom Metrics:**
  - **Purpose:** Custom metrics are critical for monitoring specific aspects of a model that generic metrics may not cover, particularly for detecting subtle types of drift that might otherwise go unnoticed.
  - **Process:** Identify the most important characteristics of the model's output or input that relate directly to business objectives or performance indicators. These characteristics will guide the development of custom metrics.
- **Implementation in MLflow:**
  - **Metric Example:** A custom metric for average prediction confidence, which can serve as an indicator of concept drift. This metric tracks changes in the modelâ€™s confidence in its predictions, which may signal an underlying shift in the data or concept.
  - **Python Code:**
    ```python
    import mlflow

    def log_prediction_confidence(predictions):
        confidence_scores = [pred.confidence for pred in predictions]  # Assuming predictions have a 'confidence' attribute
        average_confidence = sum(confidence_scores) / len(confidence_scores)
        mlflow.log_metric("average_confidence", average_confidence)

    with mlflow.start_run():
        predictions = model.predict(data)  # Ensure your model returns confidence scores
        log_prediction_confidence(predictions)
    ```
- **Practical Considerations:** 
  - **Setting Thresholds:** Determine thresholds for these metrics that, when crossed, will trigger investigations or actions. For example, a significant drop in prediction confidence might necessitate a model retraining or further data analysis.
  - **Integration with Monitoring:** Seamlessly integrate these custom metrics into your overall monitoring framework to ensure continuous observation and timely response to potential drift.

These expanded slides now provide a detailed roadmap for implementing and automating drift detection using Apache Airflow and custom metrics with MLflow, ensuring the audience can effectively plan, execute, and monitor their model maintenance strategies.
